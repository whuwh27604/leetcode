/* 最长等差数列.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
给定一个整数数组 A，返回 A 中最长等差子序列的长度。

回想一下，A 的子序列是列表 A[i_1], A[i_2], ..., A[i_k] 其中 0 <= i_1 < i_2 < ... < i_k <= A.length - 1。并且如果 B[i+1] - B[i]( 0 <= i < B.length - 1) 的值都相同，那么序列 B 是等差的。

 

示例 1：

输入：[3,6,9,12]
输出：4
解释：
整个数组是公差为 3 的等差数列。
示例 2：

输入：[9,4,7,2,10]
输出：3
解释：
最长的等差子序列是 [4,7,10]。
示例 3：

输入：[20,1,15,3,10,5,8]
输出：4
解释：
最长的等差子序列是 [20,15,10,5]。
 

提示：

2 <= A.length <= 2000
0 <= A[i] <= 10000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-arithmetic-subsequence
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

#include <iostream>
#include <algorithm>
#include <unordered_map>
#include "../check/CheckResult.h"

using namespace std;

class Solution {
public:
    int longestArithSeqLength(vector<int>& A) {
        int i, j, size = A.size(), maxLength = 2;
        vector<vector<int>> dp(size, vector<int>(size, 2));  // dp[i][j]表示等差数列结束在i,j位置时它的长度

        int* thirdLastIndex = new int[20001];  // 在i前面最后一次出现的等差数列的目标数的索引
        for (i = 0; i < 20001; ++i) {
            thirdLastIndex[i] = -1;
        }

        for (i = 0; i < size - 1; ++i) {
            for (j = i + 1; j < size; ++j) {
                int thirdLast = 2 * A[i] - A[j] + 10000;
                if (thirdLastIndex[thirdLast] != -1) {
                    dp[i][j] = dp[thirdLastIndex[thirdLast]][i] + 1;
                    maxLength = max(maxLength, dp[i][j]);
                }
            }

            thirdLastIndex[A[i] + 10000] = i;
        }

        delete[] thirdLastIndex;
        return maxLength;
    }
};

int main()
{
    CheckResult check;
    Solution o;

    vector<int> A = { 3,6,9,12 };
    check.checkInt(4, o.longestArithSeqLength(A));

    A = { 9,4,7,2,10 };
    check.checkInt(3, o.longestArithSeqLength(A));

    A = { 20,1,15,3,10,5,8 };
    check.checkInt(4, o.longestArithSeqLength(A));

    A = { 20,1 };
    check.checkInt(2, o.longestArithSeqLength(A));

    A = { 0,8,45,88,48,68,28,55,17,24 };
    check.checkInt(2, o.longestArithSeqLength(A));

    A = { 12,77,32,64,65,41,9,18,25,58,25,5,7,3,76,64,22,32,70,58,55,24,43,33,38,47,72,69,52,52,75,51,53,42,52,57,12,7,14,67,79,47,21,80,19,36,53,17,63,9,27,60,21,18,24,73,44,46,35,56,35,67,80,74,20,4,18,60,21,62,19,40,33,10,55 };
    check.checkInt(6, o.longestArithSeqLength(A));

    A = { 1,1,0,0,1,0,0,1,0,1,0,1,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,0,1,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,0,0,1,1,1,0,1,1,0,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,0,1,1,1,1,0,0,0,1,0,0,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,0,0,0,0,1,1,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1 };
    check.checkInt(306, o.longestArithSeqLength(A));
}

// 运行程序: Ctrl + F5 或调试 >“开始执行(不调试)”菜单
// 调试程序: F5 或调试 >“开始调试”菜单

// 入门使用技巧: 
//   1. 使用解决方案资源管理器窗口添加/管理文件
//   2. 使用团队资源管理器窗口连接到源代码管理
//   3. 使用输出窗口查看生成输出和其他消息
//   4. 使用错误列表窗口查看错误
//   5. 转到“项目”>“添加新项”以创建新的代码文件，或转到“项目”>“添加现有项”以将现有代码文件添加到项目
//   6. 将来，若要再次打开此项目，请转到“文件”>“打开”>“项目”并选择 .sln 文件
