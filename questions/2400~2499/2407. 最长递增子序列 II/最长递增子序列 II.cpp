/* 最长递增子序列 II.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
给你一个整数数组 nums 和一个整数 k 。

找到 nums 中满足以下要求的最长子序列：

子序列 严格递增
子序列中相邻元素的差值 不超过 k 。
请你返回满足上述要求的 最长子序列 的长度。

子序列 是从一个数组中删除部分元素后，剩余元素不改变顺序得到的数组。

 

示例 1：

输入：nums = [4,2,1,4,3,4,5,8,15], k = 3
输出：5
解释：
满足要求的最长子序列是 [1,3,4,5,8] 。
子序列长度为 5 ，所以我们返回 5 。
注意子序列 [1,3,4,5,8,15] 不满足要求，因为 15 - 8 = 7 大于 3 。
示例 2：

输入：nums = [7,4,5,1,8,12,4,7], k = 5
输出：4
解释：
满足要求的最长子序列是 [4,5,8,12] 。
子序列长度为 4 ，所以我们返回 4 。
示例 3：

输入：nums = [1,5], k = 1
输出：1
解释：
满足要求的最长子序列是 [1] 。
子序列长度为 1 ，所以我们返回 1 。
 

提示：

1 <= nums.length <= 105
1 <= nums[i], k <= 105

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/longest-increasing-subsequence-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

#include <iostream>
#include <algorithm>
#include "../check/CheckResult.h"

using namespace std;

class SegmentTree {
public:
    SegmentTree(vector<int>& nums) {
        size = nums.size();
        tree.resize(2 * size, 0);
        init(nums);
    }

    void update(int index, int value) {
        index += size;
        tree[index] = value;
        index >>= 1;

        while (index != 0) {
            tree[index] = max(tree[index * 2], tree[index * 2 + 1]);
            index >>= 1;
        }
    }

    int query(int left, int right) {
        left += size;
        right += size;
        int maximun = 0;

        while (left <= right) {
            if ((left & 1) == 1) {
                maximun = max(maximun, tree[left]);
                ++left;
            }

            if ((right & 1) == 0) {
                maximun = max(maximun, tree[right]);
                --right;
            }

            left >>= 1;
            right >>= 1;
        }

        return maximun;
    }

private:
    void init(vector<int>& nums) {
        for (int i = 0, j = size; i < size; ++i, ++j) {
            tree[j] = nums[i];
        }

        for (int i = size - 1; i > 0; --i) {
            tree[i] = tree[i * 2] + tree[i * 2 + 1];
        }
    }

    vector<int> tree;
    int size;
};

class Solution {
public:
    int lengthOfLIS(vector<int>& nums, int k) {
        int maxNum = *max_element(nums.begin(), nums.end());
        vector<int> dp(maxNum + 1, 0);
        SegmentTree tree(dp);

        /* dp[i][num]表示nums[0, i]以num为结尾的数构成的LIS
           nums[i] != num, dp[i][num] = dp[i - 1][num]
           nums[i] == num, dp[i][num] = max(dp[i - 1][num - k, num - 1]) + 1
           每一次，dp数组只有dp[i][num]会变化，这个变化要求区间dp[num - k, num - 1]的最大值 */
        for (int num : nums) {
            dp[num] = tree.query(max(1, num - k), num - 1) + 1;
            tree.update(num, dp[num]);
        }

        return tree.query(1, maxNum);
    }
};

int main()
{
    CheckResult check;
    Solution o;

    vector<int> nums = { 4,2,1,4,3,4,5,8,15 };
    check.checkInt(5, o.lengthOfLIS(nums, 3));

    nums = { 7,4,5,1,8,12,4,7 };
    check.checkInt(4, o.lengthOfLIS(nums, 5));

    nums = { 1,5 };
    check.checkInt(1, o.lengthOfLIS(nums, 1));

    nums = { 10557,27526,85273,60066,12674,44421,23268,54934,21501,35257,5187,10448,81685,65050,74042,79389,37137,85655,63355,31152,84149,58432,65538,46686,62418,36805,2720,44178,26933,46192,42695,53760,79349,39176,92285,50292,14367,21898,86201,24712,18241,77587,52298,86845,62272,63154,45784,18469,57841,2127,33913,49057,91746,54893,51560,21188,820,52335,60532,64193,21684,65046,60529,96204,1539,90094,48510,86979,11140,44681,21713,43698,23572,76714,21068,85150,56538,15617,36351,59499,62070,71459,18529,74998,48172,25813,94941,49302,45334,65510,84694,37011,4546,62651,48248,17744,13961,83008,29533,61655,41908,47782,92645,27099,13008,35829,86262,14993,26358,1257,36975,89387,39994,23237,95531,78506,31376,27610,29273,723,87172,60121,29982,38939,59226,34311,32075,2092,85562,18835,77593,1508,61603,3902,24887,54725,40514,80695,26966,75666,81879,89819,2202,50083,28510,32501,15283,81146,21929,23533,86513,68146,77469,11251,83319,88472,92539,62306,37486,25304,55319,80906,36389,2009,91094,86221,56831,59302,65219,14774,77002,84273,25469,99715,51232,26523,31124,63768,20656,89494,27068,35656,92709,20659,69179,44903,18351,93647,64073,63217,49191,27141,88305,28721,12779,54414,64570,13618,26330,23485,5095,71828,36149,98701,44501,64700,68519,71451,77509,81247,5631,46266,73854,36387,43323,76587,92934,36212,66508,72454,93151,46473,66105,87772,47436,84483,28004,44655,52767,89005,15222,71040,86250,86379,59744,78171,3464,60647,82395,69094,71846,130,58799,6934,38200,91960,27374,97925,43050,11899,21355,93117,40917,95439,62751,63213,30752,9385,38532,47285,29376,47365,79757,42002,39651,48981,15780,66001,90632,41733,46885,72913,87610,97636,3481,82904,43986,10179,62169,32205,40727,47455,95500,50925,15293,43611,20174,5348,40815,99136,8319,73920,82233,81410,88960,15742,24593,3521,70990,88025,82630,57616,20888,5724,34962,53861,96064,94502,68122,95577,52351,21592,94753,96192,21732,74140,66111,62449,32451,9622,46375,54873,94377,18374,94512,31762,10340,52721,78082,694,18854,35043,58037,75139,87317,58226,94532,69301,99184,53353,96715,23548,73517,40308,28773,25521,48833,89023,50162,53486,41618,48708,50199,36909,49771,51816,5384,41716,63780,77815,54213,74927,86328,78008,51652,73530,40719,80863,14747,99290,67009,82068,97300,14076,19329,97635,99423,53937,21776,4143,68511,63427,82068,11389,51508,81551,92868,64603,23534,87575,45100,84850,16783,19459,92565,67615,18062,54225,48280,92045,21122,51679,56300,28409,93300,52042,65382,27513,56745,23558,6932,25873,5677,16170,31810,15081,98557,69200,93271,34775,12465,33642,13363,34080,32349,56700,21533,94492,27938,83291,22696,5445,79151,20165,62349,63774,92791,71946,15440,32818,31255,35854,44850,73494,83260,86420,51066,21444,64916,38986,83955,38378,59672,97446,76293,33341,69859,89740,86855,28379,51950,50466,62701,74994,62243,77819,20381,22614,3837,62689,27723,86151,87473,43902,82524,70908,93798,27168,39456,94367,48857,7857,67331,33001,85132,30551,8518,37758,84303,12757,2249,97168,60196,21218,53608,56380,71444,91580,58820,48526,28154,14216,32193,87735,45697,28599,75297,43542,94313,97823,57567,26203,93281,78781,17742,76002,13302,51587,77788,96000,20016,29558,80777,11149,51568,58958,83278,44767,51863,92605,48484,23186,72141,8138,27788,80326,16837,3413,33960,807,16479,35629,17338,59661,14174,52782,94204,77643,5599,33514,814,56331,40884,17991,55427,71665,64874,29635,97972,38944,14680,62338,94752,1732,28561,55441,62406,58061,184,70000,800,38152,15361,67172,67938,69477,23309,95523,96872,38227,65390,45756,91659,6438,54488,63450,29426,96169,18638,43831,29617,17583,95649,92997,45441,97731,23323,52556,34879,47500,53854,23158 };
    check.checkInt(51, o.lengthOfLIS(nums, 98076));
}

// 运行程序: Ctrl + F5 或调试 >“开始执行(不调试)”菜单
// 调试程序: F5 或调试 >“开始调试”菜单

// 入门使用技巧: 
//   1. 使用解决方案资源管理器窗口添加/管理文件
//   2. 使用团队资源管理器窗口连接到源代码管理
//   3. 使用输出窗口查看生成输出和其他消息
//   4. 使用错误列表窗口查看错误
//   5. 转到“项目”>“添加新项”以创建新的代码文件，或转到“项目”>“添加现有项”以将现有代码文件添加到项目
//   6. 将来，若要再次打开此项目，请转到“文件”>“打开”>“项目”并选择 .sln 文件
