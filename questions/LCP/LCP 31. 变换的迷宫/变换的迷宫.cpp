/* 变换的迷宫.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
某解密游戏中，有一个 N*M 的迷宫，迷宫地形会随时间变化而改变，迷宫出口一直位于 (n-1,m-1) 位置。迷宫变化规律记录于 maze 中，maze[i] 表示 i 时刻迷宫的地形状态，"." 表示可通行空地，"#" 表示陷阱。

地形图初始状态记作 maze[0]，此时小力位于起点 (0,0)。此后每一时刻可选择往上、下、左、右其一方向走一步，或者停留在原地。

小力背包有以下两个魔法卷轴（卷轴使用一次后消失）：

临时消除术：将指定位置在下一个时刻变为空地；
永久消除术：将指定位置永久变为空地。
请判断在迷宫变化结束前（含最后时刻），小力能否在不经过任意陷阱的情况下到达迷宫出口呢？

注意： 输入数据保证起点和终点在所有时刻均为空地。

示例 1：

输入：maze = [[".#.","#.."],["...",".#."],[".##",".#."],["..#",".#."]]

输出：true

解释：maze.gif

示例 2：

输入：maze = [[".#.","..."],["...","..."]]

输出：false

解释：由于时间不够，小力无法到达终点逃出迷宫。

示例 3：

输入：maze = [["...","...","..."],[".##","###","##."],[".##","###","##."],[".##","###","##."],[".##","###","##."],[".##","###","##."],[".##","###","##."]]

输出：false

解释：由于道路不通，小力无法到达终点逃出迷宫。

提示：

1 <= maze.length <= 100
1 <= maze[i].length, maze[i][j].length <= 50
maze[i][j] 仅包含 "."、"#"
*/

#include <iostream>
#include <queue>
#include "../check/CheckResult.h"

using namespace std;

class Node {
public:
    int t;
    int r;
    int c;
    int scroll;

    Node() : t(0), r(0), c(0), scroll(3) {}
    Node(int t_, int r_, int c_, int s_) : t(t_), r(r_), c(c_), scroll(s_) {}
};

class Solution {
public:
    bool escapeMaze(vector<vector<string>>& maze) {
        int dr[5] = { 0,0,1,0,-1 }, dc[5] = { 0,1,0,-1,0 };
        time = (int)maze.size(), row = (int)maze[0].size(), column = (int)maze[0][0].size();
        queue<Node> nodes;
        Node node;
        nodes.push(node);
        vector<bool> visited(time * row * column * 4, false);
        visited[hash(node)] = true;

        while (!nodes.empty()) {
            Node node = nodes.front();
            nodes.pop();

            for (int i = 0; i < 5; ++i) {
                int nt = node.t + 1, nr = node.r + dr[i], nc = node.c + dc[i];
                if (nt == time || nr < 0 || nr >= row || nc < 0 || nc >= column) {
                    continue;
                }

                if (nr == row - 1 && nc == column - 1) {
                    return true;
                }

                if (maze[nt][nr][nc] == '.') {
                    push(Node(nt, nr, nc, node.scroll), nodes, visited);
                }
                else {
                    if ((node.scroll & 1) != 0) {
                        push(Node(nt, nr, nc, node.scroll ^ 1), nodes, visited);
                    }

                    if ((node.scroll & 2) != 0) {
                        for (int t = nt; t < time; ++t) {
                            push(Node(t, nr, nc, node.scroll ^ 2), nodes, visited);
                        }
                    }
                }
            }
        }

        return false;
    }

    void push(Node node, queue<Node>& nodes, vector<bool>& visited) {
        int key = hash(node);
        if (!visited[key]) {
            visited[key] = true;
            nodes.push(node);
        }
    }

    int hash(Node& node) {
        return node.t * row * column * 4 + node.r * column * 4 + node.c * 4 + node.scroll;
    }

    int time = 0;
    int row = 0;
    int column = 0;
};

int main()
{
    Solution o;
    CheckResult check;

    vector<vector<string>> maze = { {"...."},{"...."},{".##."},{"...."} };
    check.checkBool(true, o.escapeMaze(maze));

    maze = { {".#.","#.."},{"...",".#."},{".##",".#."},{"..#",".#."} };
    check.checkBool(true, o.escapeMaze(maze));

    maze = { {".."},{".."} };
    check.checkBool(true, o.escapeMaze(maze));

    maze = { {".#.","..."},{"...","..."} };
    check.checkBool(false, o.escapeMaze(maze));

    maze = { {"...."},{"...."},{".##."} };
    check.checkBool(false, o.escapeMaze(maze));

    maze = { {".#########","#.###.##.#","##########",".#.####.##",".#.##.#.#."},{".#######.#","##.#####.#",".#.#.#.###","###..#####","#####.###."},{"...######.",".###.#####","#.###.####","##.###.###",".###.#.##."},{".#########","##.#####.#","#########.",".###.#.###","##.######."},{"..##.#.###",".#########","####.##.##","..#..###.#","####.####."},{"..#..####.","##.####.##",".######..#","#.########","#..##.###."},{".#.#.#.###","######.###","####.#####","#.#.#####.",".###...#.."},{"..##..####","######.###","###.######","..##.##.#.","#######.#."},{".##.#.##..","#####.####","...#######","##.#.#.###","####..###."},{"..#.#####.","###.#####.","##..###.##","##.#.#####","###.#####."},{".#######.#","###..###..",".##.#####.","#.###.##.#","#####.#..."},{".#####.###","##..######","#.#######.","##.#.##..#","#.#.####.."},{".###..###.","##########","####..##.#",".###..##.#","###.#..##."},{".###.####.","#.###.####","###.###.##",".#########","####.#..#."},{".####.#.##","#.##.#####",".#.#.#####",".#####.#..","##.###..#."},{".#.#.#.###","#.#######.","#.####.###","###.######","#########."},{".##.##.###","##########","##.##.####","#######.##","####.###.."},{".#.######.","#########.","##.#######","########.#","########.."},{"...#######",".####.####","######.###","###.######","####.#.##."},{".######.#.","##.######.","##.##.###.",".#.#.##.#.","..#.#####."},{".##.######","########..","####...###","#########.","##...###.."},{"...##.####","###..#.###",".#..#####.","########.#","######..#."},{"..##.#####",".######..#","#####.#.##","##########","#.######.."},{".####.####","#####.#.##",".#..######","#####.####","######..#."},{".###.#.###","##.#######","#####.###.","###.######","######.##."},{".##.######","###.###.##",".#.###.###","#######.##","#.#######."},{".########.","#####.##.#","#.##.##.##","####...###",".#.#.###.."},{".#########","########.#",".##.#####.","########..","#..###...."},{".#########","####.###.#","..#.###..#","########.#","#.##.#.##."},{".#.#######","####.##...","####.#.###","#########.",".########."},{".########.","#.##.#####",".#####.#.#","###.######","#..#.####."},{".#.###.###","####.##.##","##.#..#..#","######.###","##.#####.."},{".###.#####","#####.####","##..####..","#.#.######","#########."},{".####.####","###.#..#.#",".#.####.##","###..###.#","#####..##."},{".###.##.##","#.#.#.#.#.","####.###..","#######.#.","#.#######."},{".#.##...##","###.#.####","#####.#.##","##.######.","#########."},{".###.#####","#.######.#","######.###","..#####.##","#####.###."} };
    check.checkBool(false, o.escapeMaze(maze));
}

// 运行程序: Ctrl + F5 或调试 >“开始执行(不调试)”菜单
// 调试程序: F5 或调试 >“开始调试”菜单

// 入门使用技巧: 
//   1. 使用解决方案资源管理器窗口添加/管理文件
//   2. 使用团队资源管理器窗口连接到源代码管理
//   3. 使用输出窗口查看生成输出和其他消息
//   4. 使用错误列表窗口查看错误
//   5. 转到“项目”>“添加新项”以创建新的代码文件，或转到“项目”>“添加现有项”以将现有代码文件添加到项目
//   6. 将来，若要再次打开此项目，请转到“文件”>“打开”>“项目”并选择 .sln 文件
