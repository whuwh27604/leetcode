/* 子数组和排序后的区间和.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
给你一个数组 nums ，它包含 n 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含 n * (n + 1) / 2 个数字的数组。

请你返回在新数组中下标为 left 到 right （下标从 1 开始）的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。

 

示例 1：

输入：nums = [1,2,3,4], n = 4, left = 1, right = 5
输出：13
解释：所有的子数组和为 1, 3, 6, 10, 2, 5, 9, 3, 7, 4 。将它们升序排序后，我们得到新的数组 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 1 到 ri = 5 的和为 1 + 2 + 3 + 3 + 4 = 13 。
示例 2：

输入：nums = [1,2,3,4], n = 4, left = 3, right = 4
输出：6
解释：给定数组与示例 1 一样，所以新数组为 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 3 到 ri = 4 的和为 3 + 3 = 6 。
示例 3：

输入：nums = [1,2,3,4], n = 4, left = 1, right = 10
输出：50
 

提示：

1 <= nums.length <= 10^3
nums.length == n
1 <= nums[i] <= 100
1 <= left <= right <= n * (n + 1) / 2

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/range-sum-of-sorted-subarray-sums
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

#include <iostream>
#include <algorithm>
#include "../check/CheckResult.h"

using namespace std;

class Solution {
public:
    int rangeSum(vector<int>& nums, int n, int left, int right) {
        int minimum = 1;
        vector<long long> presum(nums.size() + 1);
        getPresum(nums, presum, minimum);

        vector<long long> prepresum(presum.size());  // 用来快速计算从某个位置i开始的多个连续的区间[i,i+1],[i,i+2]...的和的总和
        getPrepresum(presum, prepresum);

        return (int)((binarySearch(presum, prepresum, minimum, right) - binarySearch(presum, prepresum, minimum, left - 1)) % 1000000007);
    }

    void getPresum(vector<int>& nums, vector<long long>& presum, int& minimum) {
        presum[0] = 0;

        for (int i = 0; i < (int)nums.size(); ++i) {
            presum[i + 1] = presum[i] + nums[i];
            minimum = min(minimum, nums[i]);
        }
    }

    void getPrepresum(vector<long long>& presum, vector<long long>& prepresum) {
        prepresum[0] = 0;

        for (int i = 1; i < (int)presum.size(); ++i) {
            prepresum[i] = prepresum[i - 1] + presum[i];
        }
    }

    long long binarySearch(vector<long long>& presum, vector<long long>& prepresum, int minimum, int rank) {
        int low = minimum - 1, high = (int)presum.back();  // 注意minimum可能就有多个，low要设置的比它小
        long long sum, firstRankSum = 0;

        while (low <= high) {
            int middle = (low + high) / 2;
            int intervals = countIntervalsNoGreaterK(presum, prepresum, middle, sum);

            if (intervals > rank) {
                high = middle - 1;  // 小于等于middle的区间个数超过了rank，那么middle肯定不是排在第rank的区间和
            }
            else if (intervals < rank) {
                low = middle + 1;  // 如果小于等于middle的区间个数小于rank，middle+1的个数有可能就超了，先记录一个可能的答案
                firstRankSum = sum + ((long long)rank - intervals) * ((long long)middle + 1);
            }
            else {
                firstRankSum = sum;
                break;
            }
        }

        return firstRankSum;
    }

    int countIntervalsNoGreaterK(vector<long long>& presum, vector<long long>& prepresum, int k, long long& sum) {
        int i, j = 1, size = presum.size(), count = 0;
        sum = 0;

        for (i = 1; i < size; ++i) {
            if (j < i) {
                j = i;
            }

            while (j < size && presum[j] - presum[i - 1] <= k) {  // 区间[i,j]的和小于k，继续扩大区间
                ++j;
            }

            count += (j - i);
            sum += (prepresum[j - 1] - prepresum[i - 1] - ((long long)j - i) * presum[i - 1]);  // 所有满足条件的区间的和的总和
        }

        return count;
    }
};

int main()
{
    CheckResult check;
    Solution o;

    vector<int> nums = { 1,2,3,4 };
    check.checkInt(13, o.rangeSum(nums, 4, 1, 5));

    nums = { 1,2,3,4 };
    check.checkInt(6, o.rangeSum(nums, 4, 3, 4));

    nums = { 1,2,3,4 };
    check.checkInt(6, o.rangeSum(nums, 4, 1, 3));

    nums = { 1,2,3,4 };
    check.checkInt(50, o.rangeSum(nums, 4, 1, 10));

    nums = { 7,5,8,5,6,4,3,3 };
    check.checkInt(23, o.rangeSum(nums, 8, 2, 6));

    nums = { 7,5,9,1,2,1,5 };
    check.checkInt(3, o.rangeSum(nums, 7, 2, 3));

    nums = { 100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100 };
    check.checkInt(716699888, o.rangeSum(nums, 1000, 1, 500500));
}

// 运行程序: Ctrl + F5 或调试 >“开始执行(不调试)”菜单
// 调试程序: F5 或调试 >“开始调试”菜单

// 入门使用技巧: 
//   1. 使用解决方案资源管理器窗口添加/管理文件
//   2. 使用团队资源管理器窗口连接到源代码管理
//   3. 使用输出窗口查看生成输出和其他消息
//   4. 使用错误列表窗口查看错误
//   5. 转到“项目”>“添加新项”以创建新的代码文件，或转到“项目”>“添加现有项”以将现有代码文件添加到项目
//   6. 将来，若要再次打开此项目，请转到“文件”>“打开”>“项目”并选择 .sln 文件
